[
  {
    "objectID": "analysis_text.html",
    "href": "analysis_text.html",
    "title": "Analysis Code",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport glob \n# import natsort\n\n# files = natsort.realsorted(glob.glob(\"data/*\"))\nfor N in 8,16,32:\n    files = glob.glob(f\"data/*N{N}*\")\n    print(files)\n    Ts = []\n    bs = []\n    for f in files:\n        data = np.load(f)\n        print(f) #use split to get N and T\n        T = float(f.split(\"T\")[1].split(\"N\")[0])\n        N = int(f.split(\"N\")[1].split(\".npz\")[0])\n        energy = data['energy']\n        mag = data['magnetisation']\n        \n        binder = 1-np.mean(mag**4)/3./np.mean(mag**2)**2\n        Ts.append(T)\n        bs.append(binder)\n        \n    plt.scatter(Ts,bs)\nplt.show()",
    "crumbs": [
      "Main Code",
      "Analysis Code"
    ]
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "Week 2",
    "section": "",
    "text": "Critical exponents\n\ncritical behaviour relates to what happens around the critical temperature\ncritical exponent defines how a certain parameter grows around the critical temperature to first order in exponent\n\nDid exercies calculating theoretical critical exponnets for spin moment (β) and susceplitibility (γ) with and without field and the exponent for changing magnetic field (δ) with constant critical temperature\nScaling relations\n\ncritical exponents can have relations to one another, α + 2β + γ = 2, γ = β(δ − 1)\n\nScale -althought a mean field theory, seems to be more mathematically exact with higher dimensionality\nUsed in calculating/understanding critical exponents\n\nEdinburgh notes on mean field theory - Ising model\nStatistical Mechanics of phase transitions\n\n\n\n\n\n- Running time calibration\n    - Running time as function of size of the box\n    - Running time as function of total MC steps\n- deviations of numerically calulcated magnetisation from analytical solution (SEE [wikipedia: Exact_solution](https://en.wikipedia.org/wiki/Square_lattice_Ising_model#Exact_solution))\n- Critical exponents\n    - good experimental work on finding critical exponents using monte carlo methods\n    - find for higher dimensions\n- Later Ideas  \n    - Universality\n    - Renormalisation group",
    "crumbs": [
      "Week 2"
    ]
  },
  {
    "objectID": "week2.html#pdf-session-2",
    "href": "week2.html#pdf-session-2",
    "title": "Week 2",
    "section": "",
    "text": "Critical exponents\n\ncritical behaviour relates to what happens around the critical temperature\ncritical exponent defines how a certain parameter grows around the critical temperature to first order in exponent\n\nDid exercies calculating theoretical critical exponnets for spin moment (β) and susceplitibility (γ) with and without field and the exponent for changing magnetic field (δ) with constant critical temperature\nScaling relations\n\ncritical exponents can have relations to one another, α + 2β + γ = 2, γ = β(δ − 1)\n\nScale -althought a mean field theory, seems to be more mathematically exact with higher dimensionality\nUsed in calculating/understanding critical exponents\n\nEdinburgh notes on mean field theory - Ising model\nStatistical Mechanics of phase transitions",
    "crumbs": [
      "Week 2"
    ]
  },
  {
    "objectID": "week2.html#ideas-for-how-to-orient-project",
    "href": "week2.html#ideas-for-how-to-orient-project",
    "title": "Week 2",
    "section": "",
    "text": "- Running time calibration\n    - Running time as function of size of the box\n    - Running time as function of total MC steps\n- deviations of numerically calulcated magnetisation from analytical solution (SEE [wikipedia: Exact_solution](https://en.wikipedia.org/wiki/Square_lattice_Ising_model#Exact_solution))\n- Critical exponents\n    - good experimental work on finding critical exponents using monte carlo methods\n    - find for higher dimensions\n- Later Ideas  \n    - Universality\n    - Renormalisation group",
    "crumbs": [
      "Week 2"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Information",
    "section": "",
    "text": "Information\nIsing Model Project Lab Book - Giancarlo Ramirez\nemail: zj22662@bristol.ac.uk",
    "crumbs": [
      "Information"
    ]
  },
  {
    "objectID": "main_code_text.html",
    "href": "main_code_text.html",
    "title": "Main Code",
    "section": "",
    "text": "# -*- coding: utf-8 -*-\n\"\"\"\nSpyder Editor\n\nThis is a temporary script file.\n\"\"\"\nfrom __future__ import division\nimport numpy as np\nfrom numpy.random import rand\nimport matplotlib.pyplot as plt\nfrom numba import njit\nimport scipy.stats \nimport tqdm\n\n#----------------------------------------------------------------------\n##  BLOCK OF FUNCTIONS USED IN THE MAIN CODE\n#----------------------------------------------------------------------\n\n\ndef initialstate(N):   \n    ''' generates a random spin configuration for initial condition'''\n    state = 2*np.random.randint(2, size=(N,N))-1\n    return state\n\n@njit\ndef mcmove(config, beta, N):\n    '''Monte Carlo move using Metropolis algorithm '''\n    for i in range(N):\n        for j in range(N):\n                a = np.random.randint(0, N)\n                b = np.random.randint(0, N)\n                s =  config[a, b]\n                nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]\n                cost = 2*s*nb\n                if cost &lt; 0:\n                    s *= -1\n                elif rand() &lt; np.exp(-cost*beta):\n                    s *= -1\n                config[a, b] = s\n    return config\n\n@njit\ndef calcEnergy(config, N):\n    '''Energy of a given configuration'''\n    energy = 0\n    for i in range(len(config)):\n        for j in range(len(config)):\n            S = config[i,j]\n            nb = config[(i+1)%N, j] + config[i,(j+1)%N] + config[(i-1)%N, j] + config[i,(j-1)%N]\n            energy += -nb*S\n    return energy/4.\n\n@njit\ndef calcMag(config):\n    '''Magnetization of a given configuration'''\n    mag = np.sum(config)\n    return mag\n\n\n## change these parameters for a smaller (faster) simulation \nnt      = 10      #  number of temperature points\nn       = [8,16,32]         #  size of the lattice, N x N\neqSteps = 1024       #  number of MC sweeps for equilibration\nmcSteps = 1024*10       #  number of MC sweeps for calculation\n\nT       = np.linspace(1.53, 3.28, nt)  #good spread tro show near temperature 3.28\nE,M,C,X = np.zeros(nt), np.zeros(nt), np.zeros(nt), np.zeros(nt)\n#n1, n2  = 1.0/(mcSteps*n*N), 1.0/(mcSteps*mcSteps*N*N) \n# divide by number of samples, and by system size to get intensive values\n\n\n\n#----------------------------------------------------------------------\n#  MAIN PART OF THE CODE\n#----------------------------------------------------------------------\n\n\n\ndef create_data():\n    M_final = []\n    E_final = []\n    \n    for N in n:\n        M = []\n        E = []\n        \n        for tt in range(nt):\n            print(T[tt],N)\n            E1 = M1 = E2 = M2 = 0\n            m_i = np.zeros(mcSteps)\n            e_i = np.zeros(mcSteps)\n            config = initialstate(N)\n            iT=1.0/T[tt]; iT2=iT*iT;\n            \n            \n            for i in range(eqSteps):         # equilibrate\n                mcmove(config, iT, N)           # Monte Carlo moves\n        \n            # for i in tqdm.tqdm(range(mcSteps)):\n            for i in range(mcSteps):\n                mcmove(config, iT, N)           \n                Ene = calcEnergy(config, N)     # calculate the energy\n                Mag = calcMag(config)        # calculate the magnetisation\n                m_i[i]= Mag\n                e_i[i] = Ene\n                \n                \n            print(T[tt],N,m_i.mean()/N**2)\n            # M.append(m_i)\n            # E.append(e_i)\n            np.savez(f\"data/run-T{T[tt]}N{N}.npz\",energy=e_i,magnetisation=m_i)\n            #E[tt] = n1*E1\n            #M[tt] = n1*M1\n            #C[tt] = (n1*E2 - n2*E1*E1)*iT2\n            #X[tt] = (n1*M2 - n2*M1*M1)*iT\n        # M_final.append(M)\n        # E_final.append(E)      \n    \n    # return M_final, E_final\n\n    \ncreate_data()\n# M_final, E_final = creat_data()\n\n\ndef stat_plot_sizes(stat_func, stat_name=\"Statistic\"):\n    \"\"\"\n    stat_func: a function like kurtosis, np.mean, etc.\n    stat_name: label to show on the y-axis\n    \"\"\"\n    \n    # --- Plot Energy statistic vs Temperature ---\n    \n    plt.figure(figsize=(8, 5))\n    for a in range(3):\n        # Compute the statistic for each temperature\n        stat_values_E = [stat_func(energy_samples) for energy_samples in E_final[a]]\n        \n        # Plot\n        plt.plot(T, stat_values_E, marker='o', label=f'N={n[a]}')\n    \n    plt.xlabel(\"Temperature (T)\", fontsize=14)\n    plt.ylabel(f\"{stat_name} of Energy\", fontsize=14)\n    plt.title(f\"{stat_name} of Energy vs Temperature\", fontsize=16)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n    \n    # --- Plot Magnetization statistic vs Temperature ---\n    plt.figure(figsize=(8, 5))\n    for a in range(3):\n        # Compute the statistic for each temperature\n        stat_values_M = [stat_func(mag_samples) for mag_samples in M_final[a]]\n        \n        # Plot\n        plt.plot(T, stat_values_M, marker='s', label=f'N={n[a]}')\n    \n    plt.xlabel(\"Temperature (T)\", fontsize=14)\n    plt.ylabel(f\"{stat_name} of Magnetization\", fontsize=14)\n    plt.title(f\"{stat_name} of Magnetization vs Temperature\", fontsize=16)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\ndef plot_iterations_for_temperature(Final_list, T, temp_index, size_index, property_name):\n    \"\"\"\n    Plots either Magnetization or Energy vs iteration for all lattice sizes\n    at a chosen temperature index.\n    \n    Parameters:\n    -----------\n    M_final      : list of lists of lists\n                   M_final[i][j] is the magnetization time-series for \n                   lattice size n_list[i] at T[j].\n    E_final      : list of lists of lists\n                   E_final[i][j] is the energy time-series for \n                   lattice size n_list[i] at T[j].\n    n_list       : list of lattice sizes used (e.g. [8, 16, 32])\n    T            : array or list of temperatures\n    temp_index   : int\n                   Index in T for which we want to plot property vs iteration\n    property_name: str, optional\n                   'Magnetization' or 'Energy' (default is 'Magnetization')\n    \"\"\"\n    # Create figure\n    plt.figure(figsize=(8, 5))\n    \n    \n    data = M_final[size_index][temp_index]\n    ylabel = property_name\n\n    # Plot data vs iteration\n    plt.plot(range(len(data)), data, label=f'N = {n[size_index]}')\n    \n    # Labeling\n    plt.xlabel(\"Iteration\", fontsize=12)\n    plt.ylabel(ylabel, fontsize=12)\n    plt.title(f\"{ylabel} vs. Iteration at T = {T[temp_index]:.2f}\", fontsize=14)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\n\n\n\n\n\n# plot_iterations_for_temperature(M_final, T, 2, 2, \"Magnetisation\")\n#stat_plot_sizes(kurtosis, \"Kurtosis\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# class Ising():\n#     ''' Simulating the Ising model '''    \n#     ## monte carlo moves\n#     def mcmove(self, config, N, beta):\n#         ''' This is to execute the monte carlo moves using \n#         Metropolis algorithm such that detailed\n#         balance condition is satisified'''\n#         for i in range(N):\n#             for j in range(N):            \n#                     a = np.random.randint(0, N)\n#                     b = np.random.randint(0, N)\n#                     s =  config[a, b]\n#                     nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]\n#                     cost = 2*s*nb\n#                     if cost &lt; 0:  \n#                         s *= -1\n#                     elif rand() &lt; np.exp(-cost*beta):\n#                         s *= -1\n#                     config[a, b] = s\n#         return config\n    \n#     def simulate(self):   \n#         ''' This module simulates the Ising model'''\n#         N, temp     = 64, .4        # Initialse the lattice\n#         config = 2*np.random.randint(2, size=(N,N))-1\n#         f = plt.figure(figsize=(15, 15), dpi=80);    \n#         self.configPlot(f, config, 0, N, 1);\n        \n#         msrmnt = 1001\n#         for i in range(msrmnt):\n#             self.mcmove(config, N, 1.0/temp)\n#             if i == 1:       self.configPlot(f, config, i, N, 2);\n#             if i == 4:       self.configPlot(f, config, i, N, 3);\n#             if i == 32:      self.configPlot(f, config, i, N, 4);\n#             if i == 100:     self.configPlot(f, config, i, N, 5);\n#             if i == 1000:    self.configPlot(f, config, i, N, 6);\n                 \n                    \n#     def configPlot(self, f, config, i, N, n_):\n#         ''' This modules plts the configuration once passed to it along with time etc '''\n#         X, Y = np.meshgrid(range(N), range(N))\n#         sp =  f.add_subplot(3, 3, n_ )  \n#         plt.setp(sp.get_yticklabels(), visible=False)\n#         plt.setp(sp.get_xticklabels(), visible=False)      \n#         plt.pcolormesh(X, Y, config, cmap=plt.cm.RdBu);\n#         plt.title('Time=%d'%i); plt.axis('tight')    \n#     plt.show()\n\n# rm = Ising()\n\n# rm.simulate()",
    "crumbs": [
      "Main Code",
      "Main Code"
    ]
  },
  {
    "objectID": "notebook.html",
    "href": "notebook.html",
    "title": "Example in jupyter",
    "section": "",
    "text": "from __future__ import division\nimport numpy as np\nfrom numpy.random import rand\nimport matplotlib.pyplot as plt\n\n\n#----------------------------------------------------------------------\n##  BLOCK OF FUNCTIONS USED IN THE MAIN CODE\n#----------------------------------------------------------------------\ndef initialstate(N):   \n    ''' generates a random spin configuration for initial condition'''\n    state = 2*np.random.randint(2, size=(N,N))-1\n    return state\n\n\ndef mcmove(config, beta):\n    '''Monte Carlo move using Metropolis algorithm '''\n    for i in range(N):\n        for j in range(N):\n                a = np.random.randint(0, N)\n                b = np.random.randint(0, N)\n                s =  config[a, b]\n                nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]\n                cost = 2*s*nb\n                if cost &lt; 0:\n                    s *= -1\n                elif rand() &lt; np.exp(-cost*beta):\n                    s *= -1\n                config[a, b] = s\n    return config\n\n\ndef calcEnergy(config):\n    '''Energy of a given configuration'''\n    energy = 0\n    for i in range(len(config)):\n        for j in range(len(config)):\n            S = config[i,j]\n            nb = config[(i+1)%N, j] + config[i,(j+1)%N] + config[(i-1)%N, j] + config[i,(j-1)%N]\n            energy += -nb*S\n    return energy/4.\n\n\ndef calcMag(config):\n    '''Magnetization of a given configuration'''\n    mag = np.sum(config)\n    return mag\n\n\n## change these parameters for a smaller (faster) simulation \nnt      = 4        #  number of temperature points\nN       = 16         #  size of the lattice, N x N\neqSteps = 1024       #  number of MC sweeps for equilibration\nmcSteps = 1024       #  number of MC sweeps for calculation\n\nT       = np.linspace(1.53, 3.28, nt) \nE,M,C,X = np.zeros(nt), np.zeros(nt), np.zeros(nt), np.zeros(nt)\nn1, n2  = 1.0/(mcSteps*N*N), 1.0/(mcSteps*mcSteps*N*N) \n# divide by number of samples, and by system size to get intensive values\n\n7 mins nt = 10 # number of temperature points N = 32 # size of the lattice, N x N eqSteps = 1024 # number of MC sweeps for equilibration mcSteps = 1024 # number of MC sweeps for calculation\n20seconds nt = 4 N = 16\n\n#----------------------------------------------------------------------\n#  MAIN PART OF THE CODE\n#----------------------------------------------------------------------\nfor tt in range(nt):\n    print(tt)\n    E1 = M1 = E2 = M2 = 0\n    config = initialstate(N)\n    iT=1.0/T[tt]; iT2=iT*iT;\n    \n    for i in range(eqSteps):         # equilibrate\n        mcmove(config, iT)           # Monte Carlo moves\n\n    for i in range(mcSteps):\n        mcmove(config, iT)           \n        Ene = calcEnergy(config)     # calculate the energy\n        Mag = calcMag(config)        # calculate the magnetisation\n\n        E1 = E1 + Ene\n        M1 = M1 + Mag\n        M2 = M2 + Mag*Mag \n        E2 = E2 + Ene*Ene\n\n    E[tt] = n1*E1\n    M[tt] = n1*M1\n    C[tt] = (n1*E2 - n2*E1*E1)*iT2\n    X[tt] = (n1*M2 - n2*M1*M1)*iT\n\n0\n1\n2\n3\n\n\n\nf = plt.figure(figsize=(9, 5)); # plot the calculated values    \n\nsp =  f.add_subplot(1, 1, 1 );\nplt.scatter(T, E, s=50, marker='o', color='IndianRed')\nplt.xlabel(\"Temperature (T)\", fontsize=20);\nplt.ylabel(\"Energy \", fontsize=20);         plt.axis('tight');\n\nsp =  f.add_subplot(1, 1, 2 );\nplt.scatter(T, abs(M), s=50, marker='o', color='RoyalBlue')\nplt.xlabel(\"Temperature (T)\", fontsize=20); \nplt.ylabel(\"Magnetization \", fontsize=20);   plt.axis('tight');\n\nsp =  f.add_subplot(1, 1, 3 );\nplt.scatter(T, C, s=50, marker='o', color='IndianRed')\nplt.xlabel(\"Temperature (T)\", fontsize=20);  \nplt.ylabel(\"Specific Heat \", fontsize=20);   plt.axis('tight');   \n\nsp =  f.add_subplot(1, 1, 4 );\nplt.scatter(T, X, s=50, marker='o', color='RoyalBlue')\nplt.xlabel(\"Temperature (T)\", fontsize=20); \nplt.ylabel(\"Susceptibility\", fontsize=20);   plt.axis('tight');\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[24], line 8\n      5 plt.xlabel(\"Temperature (T)\", fontsize=20);\n      6 plt.ylabel(\"Energy \", fontsize=20);         plt.axis('tight');\n----&gt; 8 sp =  f.add_subplot(1, 1, 2 );\n      9 plt.scatter(T, abs(M), s=50, marker='o', color='RoyalBlue')\n     10 plt.xlabel(\"Temperature (T)\", fontsize=20); \n\nFile ~/Documents/Ising_Project/minimal-quarto-lab-book/venv/lib/python3.13/site-packages/matplotlib/figure.py:768, in FigureBase.add_subplot(self, *args, **kwargs)\n    766         args = tuple(map(int, str(args[0])))\n    767     projection_class, pkw = self._process_projection_requirements(**kwargs)\n--&gt; 768     ax = projection_class(self, *args, **pkw)\n    769     key = (projection_class, pkw)\n    770 return self._add_axes_internal(ax, key)\n\nFile ~/Documents/Ising_Project/minimal-quarto-lab-book/venv/lib/python3.13/site-packages/matplotlib/axes/_base.py:656, in _AxesBase.__init__(self, fig, facecolor, frameon, sharex, sharey, label, xscale, yscale, box_aspect, forward_navigation_events, *args, **kwargs)\n    654 else:\n    655     self._position = self._originalPosition = mtransforms.Bbox.unit()\n--&gt; 656     subplotspec = SubplotSpec._from_subplot_args(fig, args)\n    657 if self._position.width &lt; 0 or self._position.height &lt; 0:\n    658     raise ValueError('Width and height specified must be non-negative')\n\nFile ~/Documents/Ising_Project/minimal-quarto-lab-book/venv/lib/python3.13/site-packages/matplotlib/gridspec.py:589, in SubplotSpec._from_subplot_args(figure, args)\n    587 else:\n    588     if not isinstance(num, Integral) or num &lt; 1 or num &gt; rows*cols:\n--&gt; 589         raise ValueError(\n    590             f\"num must be an integer with 1 &lt;= num &lt;= {rows*cols}, \"\n    591             f\"not {num!r}\"\n    592         )\n    593     i = j = num\n    594 return gs[i-1:j]\n\nValueError: num must be an integer with 1 &lt;= num &lt;= 1, not 2\n\n\n\n\n\n\n\n\n\n\n\nclass Ising():\n    ''' Simulating the Ising model '''    \n    ## monte carlo moves\n    def mcmove(self, config, N, beta):\n        ''' This is to execute the monte carlo moves using \n        Metropolis algorithm such that detailed\n        balance condition is satisified'''\n        for i in range(N):\n            for j in range(N):            \n                    a = np.random.randint(0, N)\n                    b = np.random.randint(0, N)\n                    s =  config[a, b]\n                    nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]\n                    cost = 2*s*nb\n                    if cost &lt; 0:    \n                        s *= -1\n                    elif rand() &lt; np.exp(-cost*beta):\n                        s *= -1\n                    config[a, b] = s\n        return config\n    \n    def simulate(self):   \n        ''' This module simulates the Ising model'''\n        N, temp     = 64, .4        # Initialse the lattice\n        config = 2*np.random.randint(2, size=(N,N))-1\n        f = plt.figure(figsize=(15, 15), dpi=80);    \n        self.configPlot(f, config, 0, N, 1);\n        \n        msrmnt = 1001\n        for i in range(msrmnt):\n            self.mcmove(config, N, 1.0/temp)\n            if i == 1:       self.configPlot(f, config, i, N, 2);\n            if i == 4:       self.configPlot(f, config, i, N, 3);\n            if i == 32:      self.configPlot(f, config, i, N, 4);\n            if i == 100:     self.configPlot(f, config, i, N, 5);\n            if i == 1000:    self.configPlot(f, config, i, N, 6);\n                 \n                    \n    def configPlot(self, f, config, i, N, n_):\n        ''' This modules plts the configuration once passed to it along with time etc '''\n        X, Y = np.meshgrid(range(N), range(N))\n        sp =  f.add_subplot(3, 3, n_ )  \n        plt.setp(sp.get_yticklabels(), visible=False)\n        plt.setp(sp.get_xticklabels(), visible=False)      \n        plt.pcolormesh(X, Y, config, cmap=plt.cm.RdBu);\n        plt.title('Time=%d'%i); plt.axis('tight')    \n    plt.show()\n\n\nrm = Ising()\n\n\nrm.simulate()"
  },
  {
    "objectID": "week1.html",
    "href": "week1.html",
    "title": "Week 1",
    "section": "",
    "text": "Topics:\n\nRenormalisation\nCritical exponents\nScaling laws\nPhase transitions\nClusters\nFundamental model\nMetropolis algorithm\nBlueCrystal HPC\n\nResearch and understand/experiment with code\nAim idea: ‘create popular account using research as structure’\n\n\n\n\n\nIntro\n\nMonte Carlo sampling method\nUse Ising to model magnetism, understand magnetic phase transition\nMain: 2D-square lattice, investigate parameters close to phase transition\nExtra: exact solution 1D, Potts/XY models 2D\n\nPhase transitions\n\nVan der Waals example, gas doesn’t resist being compressed —&gt; must have phase transition\nMagnetism\n\nAll sites spin up/down\nNeighbouring atoms favour same direction, absolute zero has ground states ,all down(m=-ve)/up(m=+ve)\nAbove T=0, entropy favours random spin, high temperatures —&gt; p=1/2 for up/down —&gt; M=0 (zero external field)\nCritical temp T_c when M=0\n\nOther PT’s: superfluids, superconductors\nPT example of spontaneously-broken symmetry\n\nIsing Model\n\nEach site assigned spin value σ = ±1 (up or down)\nEnergy Hamiltonian, H = − Σ J.σ_i.σ_j − Σ B.σ_i , can be hard to calculate, N sites —&gt; 2^N configurations of system\nFirst Σ over all NN’s (2D - 4 bonds),\n\nJ: exchange energy,\n\nJ &lt; 0 —&gt; system favours NN’s same direction spin (ferromagnet), J&gt;0 —&gt; anti-ferromagnet\n\n\nNote: not using SI units in computation , (σ =±ℏ/2)\nNote: real magnetic system, spin can be in any direction —&gt;crystal lattice leads to preferred directions —&gt; ‘spin-orbit’ coupling\nNote: Ising model can be used to model any system where each lattices site has two possible states\n\nStatistical Physics\n\nProbability of state occurring = p = (1/Z).(exp (−H/kBT))\nPartition function (Z) encodes other observables: Z = Σexp (−H/kBT), sum over all states\n\nU =  = - ∂ln(Z)/∂β = (1/Z).ΣH.exp(−H/k_B.T), β = 1/kBT\nF = −kBT ln (Z) : Helmholtz free energy\n\ndF = −SdT + MdB\nS = ∂F/∂T\n\nS = −k_B.Σp.ln(p) , ’Shannon Entropy\n\nM = ∂F/∂B\n\nM = Σ &lt;σ&gt; = ∂/∂B\n\n\n\n\nSingle site exact solution\n\nH = -Bσ = ±B , (σ = ±1)\nZ = exp (−B/kBT) + exp (B/k_B.T)\n&lt;σ&gt; = (1/Z). Σσ.exp(−H/k_B.T) = tanh (B/k_B.T)\nExercise in notebook?\n\nMean-Field Theory\n\nAssume each site experiences NN’s effects as an average effective energy\nH = − ΣB_eff.σ_i , B_eff = B + J.&lt;σ&gt;.z , z = No. Neighbours\nEach spin equivalent on average, each neighbour has same average spin\n2D-square-lattice —&gt; B_eff = B + 4.J.&lt;σ&gt;\n\nFrom single site equation, &lt;σ&gt; = tanh (B_eff /k_B.T) = tanh (B + 4.J.&lt;σ&gt; /k_B.T)\n\nTransendental equation\nIf parameter are such that zJ/kBT &gt; 1, in addition to trivial sol. &lt;σ&gt; = 0, there are two others &lt;σ&gt; &gt; 0 & &lt;σ&gt; &lt; 0\n\nSystem will spontaneously choose of these solutions &lt;—&gt; ferromagnet with spontaneous magnetic moment\nThis happens in the approx solution at T_c = z.J/k_B\nExample of Symmetry Breaking\n\n\n\n\n\n\n\n\nMetrolopolis Algorithms\n\n1: Initialise random starting configuration\n2: Choose one site randomly, calculate energy change of system if spin flipped\n3: If energy reduced –&gt; flip spin, If not –&gt; generate random number 0&lt;p&lt;1, flip if p&lt;exp(-k_b.t.delta_E), [flip with probability = boltzman factor]\n4: Iterate steps 2 and 3 until maximum number of monte carlo (MC) steps reached, observables calculated from all accepted configurations\n\nThings to calulcate\n\nRunning time as function of size of the box\nRunning time as function of total MC steps\ndeviations of numerically calulcated magnetisation from analytical solution (SEE https://en.wikipedia.org/wiki/Square_lattice_Ising_model#Exact_solution)\ncharacteristic configurations patterns for different temperatures\nexploit finite size scaling\n\n\n\n\n\n\nhttps://www.youtube.com/watch?v=OgO1gpXSUzU\nhttps://www.youtube.com/watch?v=EaR3C4e600k\nBasically random sampling and using law of large numbers (as no.trials increases –&gt; average of samples converges to true expected value)",
    "crumbs": [
      "Week 1"
    ]
  },
  {
    "objectID": "week1.html#initial-meeting",
    "href": "week1.html#initial-meeting",
    "title": "Week 1",
    "section": "",
    "text": "Topics:\n\nRenormalisation\nCritical exponents\nScaling laws\nPhase transitions\nClusters\nFundamental model\nMetropolis algorithm\nBlueCrystal HPC\n\nResearch and understand/experiment with code\nAim idea: ‘create popular account using research as structure’",
    "crumbs": [
      "Week 1"
    ]
  },
  {
    "objectID": "week1.html#pdf-session-1---key-concepts-and-background",
    "href": "week1.html#pdf-session-1---key-concepts-and-background",
    "title": "Week 1",
    "section": "",
    "text": "Intro\n\nMonte Carlo sampling method\nUse Ising to model magnetism, understand magnetic phase transition\nMain: 2D-square lattice, investigate parameters close to phase transition\nExtra: exact solution 1D, Potts/XY models 2D\n\nPhase transitions\n\nVan der Waals example, gas doesn’t resist being compressed —&gt; must have phase transition\nMagnetism\n\nAll sites spin up/down\nNeighbouring atoms favour same direction, absolute zero has ground states ,all down(m=-ve)/up(m=+ve)\nAbove T=0, entropy favours random spin, high temperatures —&gt; p=1/2 for up/down —&gt; M=0 (zero external field)\nCritical temp T_c when M=0\n\nOther PT’s: superfluids, superconductors\nPT example of spontaneously-broken symmetry\n\nIsing Model\n\nEach site assigned spin value σ = ±1 (up or down)\nEnergy Hamiltonian, H = − Σ J.σ_i.σ_j − Σ B.σ_i , can be hard to calculate, N sites —&gt; 2^N configurations of system\nFirst Σ over all NN’s (2D - 4 bonds),\n\nJ: exchange energy,\n\nJ &lt; 0 —&gt; system favours NN’s same direction spin (ferromagnet), J&gt;0 —&gt; anti-ferromagnet\n\n\nNote: not using SI units in computation , (σ =±ℏ/2)\nNote: real magnetic system, spin can be in any direction —&gt;crystal lattice leads to preferred directions —&gt; ‘spin-orbit’ coupling\nNote: Ising model can be used to model any system where each lattices site has two possible states\n\nStatistical Physics\n\nProbability of state occurring = p = (1/Z).(exp (−H/kBT))\nPartition function (Z) encodes other observables: Z = Σexp (−H/kBT), sum over all states\n\nU =  = - ∂ln(Z)/∂β = (1/Z).ΣH.exp(−H/k_B.T), β = 1/kBT\nF = −kBT ln (Z) : Helmholtz free energy\n\ndF = −SdT + MdB\nS = ∂F/∂T\n\nS = −k_B.Σp.ln(p) , ’Shannon Entropy\n\nM = ∂F/∂B\n\nM = Σ &lt;σ&gt; = ∂/∂B\n\n\n\n\nSingle site exact solution\n\nH = -Bσ = ±B , (σ = ±1)\nZ = exp (−B/kBT) + exp (B/k_B.T)\n&lt;σ&gt; = (1/Z). Σσ.exp(−H/k_B.T) = tanh (B/k_B.T)\nExercise in notebook?\n\nMean-Field Theory\n\nAssume each site experiences NN’s effects as an average effective energy\nH = − ΣB_eff.σ_i , B_eff = B + J.&lt;σ&gt;.z , z = No. Neighbours\nEach spin equivalent on average, each neighbour has same average spin\n2D-square-lattice —&gt; B_eff = B + 4.J.&lt;σ&gt;\n\nFrom single site equation, &lt;σ&gt; = tanh (B_eff /k_B.T) = tanh (B + 4.J.&lt;σ&gt; /k_B.T)\n\nTransendental equation\nIf parameter are such that zJ/kBT &gt; 1, in addition to trivial sol. &lt;σ&gt; = 0, there are two others &lt;σ&gt; &gt; 0 & &lt;σ&gt; &lt; 0\n\nSystem will spontaneously choose of these solutions &lt;—&gt; ferromagnet with spontaneous magnetic moment\nThis happens in the approx solution at T_c = z.J/k_B\nExample of Symmetry Breaking",
    "crumbs": [
      "Week 1"
    ]
  },
  {
    "objectID": "week1.html#ising-exercise-powerpoints",
    "href": "week1.html#ising-exercise-powerpoints",
    "title": "Week 1",
    "section": "",
    "text": "Metrolopolis Algorithms\n\n1: Initialise random starting configuration\n2: Choose one site randomly, calculate energy change of system if spin flipped\n3: If energy reduced –&gt; flip spin, If not –&gt; generate random number 0&lt;p&lt;1, flip if p&lt;exp(-k_b.t.delta_E), [flip with probability = boltzman factor]\n4: Iterate steps 2 and 3 until maximum number of monte carlo (MC) steps reached, observables calculated from all accepted configurations\n\nThings to calulcate\n\nRunning time as function of size of the box\nRunning time as function of total MC steps\ndeviations of numerically calulcated magnetisation from analytical solution (SEE https://en.wikipedia.org/wiki/Square_lattice_Ising_model#Exact_solution)\ncharacteristic configurations patterns for different temperatures\nexploit finite size scaling",
    "crumbs": [
      "Week 1"
    ]
  },
  {
    "objectID": "week1.html#monte-carlo-method-videos",
    "href": "week1.html#monte-carlo-method-videos",
    "title": "Week 1",
    "section": "",
    "text": "https://www.youtube.com/watch?v=OgO1gpXSUzU\nhttps://www.youtube.com/watch?v=EaR3C4e600k\nBasically random sampling and using law of large numbers (as no.trials increases –&gt; average of samples converges to true expected value)",
    "crumbs": [
      "Week 1"
    ]
  },
  {
    "objectID": "week3.html",
    "href": "week3.html",
    "title": "Week 3",
    "section": "",
    "text": "- Kurtosis/ Binder Parameter \n    - measure of \"gausian'ness\" \n    - can capture change in distribution\n- Finite size scaling\n    - plot different size systems on kurtosis vs temp\n    - all approach same value near criticality\n    - can be used to approximate critical temperature\n- Applying slight field can make system prefer one spin direction\n-Numba package\n    - Just in time computation\n    - @numba.njit decorator above function\n- Critical slowing down\n    - approaching critical point from above, system takes longer to be change\n    - Cluster move algorithms\n        - Swendsen\n        - Woldd\n    - Locality, equilibrium\n- Measuring cluster sizes?\n\n\n\n- Get plots for observables vs iterations\n- understand how to extract kurtosis efficiently for different temperatures\n- get to a plot of kurtosis vs temperature with different size systems\n##Coding work - reworked the main code to simulate for different sizes of system –&gt; different temperatures - used namba to speed up alot of functions - created plotting functions -statistic vs temperature — different system sizes -obvservable vs iteration —\n\n\n\n- adapted code to save data",
    "crumbs": [
      "Week 3"
    ]
  },
  {
    "objectID": "week3.html#meeting",
    "href": "week3.html#meeting",
    "title": "Week 3",
    "section": "",
    "text": "- Kurtosis/ Binder Parameter \n    - measure of \"gausian'ness\" \n    - can capture change in distribution\n- Finite size scaling\n    - plot different size systems on kurtosis vs temp\n    - all approach same value near criticality\n    - can be used to approximate critical temperature\n- Applying slight field can make system prefer one spin direction\n-Numba package\n    - Just in time computation\n    - @numba.njit decorator above function\n- Critical slowing down\n    - approaching critical point from above, system takes longer to be change\n    - Cluster move algorithms\n        - Swendsen\n        - Woldd\n    - Locality, equilibrium\n- Measuring cluster sizes?",
    "crumbs": [
      "Week 3"
    ]
  },
  {
    "objectID": "week3.html#coding-plan",
    "href": "week3.html#coding-plan",
    "title": "Week 3",
    "section": "",
    "text": "- Get plots for observables vs iterations\n- understand how to extract kurtosis efficiently for different temperatures\n- get to a plot of kurtosis vs temperature with different size systems\n##Coding work - reworked the main code to simulate for different sizes of system –&gt; different temperatures - used namba to speed up alot of functions - created plotting functions -statistic vs temperature — different system sizes -obvservable vs iteration —",
    "crumbs": [
      "Week 3"
    ]
  },
  {
    "objectID": "week3.html#final-meeting",
    "href": "week3.html#final-meeting",
    "title": "Week 3",
    "section": "",
    "text": "- adapted code to save data",
    "crumbs": [
      "Week 3"
    ]
  }
]