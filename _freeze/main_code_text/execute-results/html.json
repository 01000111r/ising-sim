{
  "hash": "b1113a79ab5669734c115f474e60e6a7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Main Code\"\nformat: html\nexecute:\n  eval: false\n  echo: true  # Ensures code still appears\n  freeze: auto  # Prevents execution unless manually triggered\n\n---\n\n::: {#899a0d06 .cell execution_count=1}\n``` {.python .cell-code}\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Feb 27 13:05:14 2025\n\n@author: gianc\n\"\"\"\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom __future__ import division\nimport numpy as np\nfrom numba import njit\nimport math\nimport os\nimport multiprocessing as mp\nfrom functools import partial\n\n\n# Initialise state\ndef initialstate(N, dim, model, T):\n    \"\"\"\n    Generates a spin configuration.\n    For T < Tc, we initialize in an ordered state to reduce equilibration time.\n    For T > Tc, we initialize in a random state for faster exploration.\n    \"\"\"\n    if model == 'ising':\n        # For Ising model, use ordered state (all +1) for T < 2.0, random state otherwise\n        # This helps with equilibration\n        if T < 2.0:  # Below critical temperature\n            if dim == 2:\n                return np.ones((N, N), dtype=np.int8)\n            elif dim == 3:\n                return np.ones((N, N, N), dtype=np.int8)\n        else:  # Above critical temperature\n            if dim == 2:\n                return 2 * np.random.randint(0, 2, size=(N, N), dtype=np.int8) - 1\n            elif dim == 3:\n                return 2 * np.random.randint(0, 2, size=(N, N, N), dtype=np.int8) - 1\n    else:\n        raise ValueError(\"Model must be 'ising'\")\n\n# Metropolis Algorithms\n@njit\ndef mcmove2d(config, beta, N, model, delta):\n    \"\"\"\n    One sweep of local Metropolis moves on a 2D lattice.\n    model: 0=ising, 1=xy, 2=heisenberg.\n    \"\"\"\n    num_moves = N * N\n    for k in range(num_moves):\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        r = np.random.random()\n        if model == 0:\n            s = config[i, j]\n            nb = (config[(i+1)%N, j] + config[(i-1)%N, j] +\n                  config[i, (j+1)%N] + config[i, (j-1)%N])\n            cost = 2 * s * nb\n            if cost < 0 or r < math.exp(-beta * cost):\n                config[i, j] = -s\n    return config\n\n@njit\ndef mcmove3d(config, beta, N, model, delta):\n    \"\"\"\n    One sweep of local Metropolis moves on a 3D lattice.\n    \"\"\"\n    num_moves = N * N * N\n    for k in range(num_moves):\n        x = np.random.randint(0, N)\n        y = np.random.randint(0, N)\n        z = np.random.randint(0, N)\n        r = np.random.random()\n        if model == 0:\n            s = config[x, y, z]\n            nb = (config[(x+1)%N, y, z] + config[(x-1)%N, y, z] +\n                  config[x, (y+1)%N, z] + config[x, (y-1)%N, z] +\n                  config[x, y, (z+1)%N] + config[x, y, (z-1)%N])\n            cost = 2 * s * nb\n            if cost < 0 or r < math.exp(-beta * cost):\n                config[x, y, z] = -s\n    return config\n\n# Wolf Cluster Algorithms 2D\n@njit\ndef wolff_update_2d_ising(config, beta, N):\n    \"\"\"\n    Wolff cluster update for 2D Ising model.\n    The implementation creates and flips a single cluster.\n    \"\"\"\n    # Handle the T=0 case explicitly to avoid division by zero\n    if beta > 1e6:  # For very low temperatures\n        return config  # At T=0, no spins flip\n    \n    # Create array to store sites to be flipped (cluster membership)\n    cluster = np.zeros((N, N), dtype=np.int8)\n    \n    # Create stack to store site coordinates to be searched\n    stack = np.empty((N*N, 2), dtype=np.int64)\n    # Pointer for number of sites left to search\n    stack_ptr = 0\n    \n    # Pick a random site \n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    \n    # Get the original spin value\n    s0 = config[i, j]\n    \n    # Flip the seed spin\n    config[i, j] = -s0\n    \n    # Mark as part of cluster and add to stack\n    cluster[i, j] = 1\n    stack[0, 0] = i\n    stack[0, 1] = j\n    stack_ptr = 1\n    \n    # Probability of adding a neighbor to the cluster\n    p_add = 1.0 - math.exp(-2.0 * beta)\n\n    # Grow the cluster\n    while stack_ptr > 0:\n        stack_ptr -= 1\n        # Retrieve next site coordinates\n        i = stack[stack_ptr, 0]\n        j = stack[stack_ptr, 1]\n        \n        # For each neighbor:\n        for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):\n            ni = (i + di) % N\n            nj = (j + dj) % N\n            \n            # If neighbor is not yet in the cluster and has the same spin as the original seed:\n            if cluster[ni, nj] == 0 and config[ni, nj] == s0:\n                # Add neighbor with probability p_add\n                if np.random.random() < p_add:\n                    # Flip the neighbor to the opposite of the seed\n                    config[ni, nj] = -s0\n                    \n                    # Mark as part of cluster and add to stack\n                    cluster[ni, nj] = 1\n                    stack[stack_ptr, 0] = ni\n                    stack[stack_ptr, 1] = nj\n                    stack_ptr += 1\n                    \n    return config\n\n# 3D Cluster Updates\n@njit\ndef wolff_update_3d_ising(config, beta, N):\n    \"\"\"\n    Wolff cluster update for 3D Ising model.\n    \"\"\"\n    # Handle the T=0 case explicitly to avoid division by zero\n    if beta > 1e6:  # For very low temperatures\n        return config  # At T=0, no spins flip\n    \n    # Create array to store sites to be flipped (cluster membership)\n    cluster = np.zeros((N, N, N), dtype=np.int8)\n    \n    # Create stack to store site coordinates to be searched\n    stack = np.empty((N*N*N, 3), dtype=np.int64)\n    stack_ptr = 0\n    \n    # Pick a random site\n    x = np.random.randint(0, N)\n    y = np.random.randint(0, N)\n    z = np.random.randint(0, N)\n    \n    # Get the original spin value\n    s0 = config[x, y, z]\n    \n    # Flip the seed spin\n    config[x, y, z] = -s0\n    \n    # Mark seed as in the cluster and add to stack\n    cluster[x, y, z] = 1\n    stack[0, 0] = x\n    stack[0, 1] = y\n    stack[0, 2] = z\n    stack_ptr = 1\n    \n    # Probability of adding a neighbor to the cluster\n    p_add = 1.0 - math.exp(-2.0 * beta)\n    \n    # Grow the cluster\n    while stack_ptr > 0:\n        stack_ptr -= 1\n        x = stack[stack_ptr, 0]\n        y = stack[stack_ptr, 1]\n        z = stack[stack_ptr, 2]\n        \n        # Iterate over the six nearest neighbors in 3D\n        for dx, dy, dz in ((1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)):\n            nx = (x + dx) % N\n            ny = (y + dy) % N\n            nz = (z + dz) % N\n            \n            # If neighbor is not yet in cluster and has same spin as original seed\n            if cluster[nx, ny, nz] == 0 and config[nx, ny, nz] == s0:\n                if np.random.random() < p_add:\n                    # Flip neighbor to opposite of seed\n                    config[nx, ny, nz] = -s0\n                    \n                    # Mark as part of cluster and add to stack\n                    cluster[nx, ny, nz] = 1\n                    stack[stack_ptr, 0] = nx\n                    stack[stack_ptr, 1] = ny\n                    stack[stack_ptr, 2] = nz\n                    stack_ptr += 1\n                    \n    return config\n\n@njit\ndef wolff_update_2d(config, beta, N, model):\n    if model == 0:\n        return wolff_update_2d_ising(config, beta, N)\n    \n@njit\ndef wolff_update_3d(config, beta, N, model):\n    if model == 0:\n        return wolff_update_3d_ising(config, beta, N)\n\n\n\n#measurements\n\n\n@njit\ndef measure2d_all(config, N, model):\n    \"\"\"\n    Measures energy, magnetization, and correlation function for 2D lattice.\n    Returns the raw values - normalization happens later.\n    \"\"\"\n    R = N // 2\n    energy = 0.0\n    if model == 0:\n        mag = 0.0\n        corr = np.zeros(R+1, dtype=np.float64)\n        # Loop over all lattice sites once.\n        for i in range(N):\n            for j in range(N):\n                S = config[i, j]\n                # Energy from right and down neighbors (periodic BCs)\n                energy += -S * (config[i, (j+1)%N] + config[(i+1)%N, j])\n                mag += S\n                # Update correlation for displacements r along the i-direction.\n                for r in range(R+1):\n                    corr[r] += S * config[(i+r)%N, j]\n        # Normalize correlation (each r gets N*N contributions)\n        norm = N * N\n        for r in range(R+1):\n            corr[r] /= norm\n        return energy, mag, corr\n\n@njit\ndef measure3d_all(config, N, model):\n    \"\"\"\n    Measures energy, magnetization, and correlation function for 3D lattice.\n    \"\"\"\n    R = N // 2\n    energy = 0.0\n    if model == 0:\n        mag = 0.0\n        corr = np.zeros(R+1, dtype=np.float64)\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    S = config[x, y, z]\n                    energy += -S * (config[(x+1)%N, y, z] +\n                                    config[x, (y+1)%N, z] +\n                                    config[x, y, (z+1)%N])\n                    mag += S\n                    # Correlation along the x-direction (for each displacement r)\n                    for r in range(R+1):\n                        corr[r] += S * config[(x+r)%N, y, z]\n        norm = N * N * N\n        for r in range(R+1):\n            corr[r] /= norm\n        return energy, mag, corr\n\n@njit\ndef compute_connected_correlation(corr, mag, N, dim):\n    \"\"\"\n    Converts raw correlation to connected correlation function.\n    C_conn(r) = <S(0)S(r)> - <S>Â²\n    \"\"\"\n    R = len(corr) - 1\n    m_squared = (mag / (N**dim))**2\n    connected_corr = np.zeros_like(corr)\n    \n    for r in range(R+1):\n        connected_corr[r] = corr[r] - m_squared\n        \n    return connected_corr\n\n\n#SIMULATION\n\n\ndef run_simulation(config, beta, eqSteps, mcSteps, N, dim, model, delta, update_type):\n    \"\"\"\n    Runs equilibration then measurement sweeps with adaptive cluster update count.\n    \"\"\"\n    # Convert model to numeric code: 0=ising\n    if model == 'ising':\n        mcode = 0\n    else:\n        raise ValueError(\"Unknown model\")\n    \n\n    # Equilibration:\n    for _ in range(eqSteps):\n        if update_type == 'local':\n            if dim == 2:\n                mcmove2d(config, beta, N, mcode, delta)\n            else:\n                mcmove3d(config, beta, N, mcode, delta)\n        elif update_type == 'cluster':\n\n            if dim == 2:\n                wolff_update_2d(config, beta, N, mcode)\n            else:\n                wolff_update_3d(config, beta, N, mcode)\n    \n    # Measurement:\n    m_i = np.empty(mcSteps, dtype=np.float64)\n    e_i = np.empty(mcSteps, dtype=np.float64)\n    R = N // 2\n    corr_sum = np.zeros(R+1, dtype=np.float64)\n    \n    for i in range(mcSteps):\n        if update_type == 'local':\n            if dim == 2:\n                mcmove2d(config, beta, N, mcode, delta)\n            else:\n                mcmove3d(config, beta, N, mcode, delta)\n        elif update_type == 'cluster':\n            \n\n            if dim == 2:\n                wolff_update_2d(config, beta, N, mcode)\n            else:\n                wolff_update_3d(config, beta, N, mcode)\n        \n        if dim == 2:\n            e, m, corr = measure2d_all(config, N, mcode)\n        else:\n            e, m, corr = measure3d_all(config, N, mcode)\n        \n        e_i[i] = e\n        m_i[i] = m\n        corr_sum += corr\n    \n    corr_avg = corr_sum / mcSteps\n    \n\n    avg_mag = np.mean(m_i)\n    connected_corr = compute_connected_correlation(corr_avg, avg_mag, N, dim)\n    \n    return m_i, e_i, corr_avg, connected_corr\n\n\n\n# multiprocessor wrapper\n\ndef simulate_temp(args, output_folder, dim, model, delta, update_type):\n    \"\"\"\n    Runs simulation for given N and T_value and saves data.\n    \"\"\"\n    N, T_value, eqSteps, mcSteps = args\n    \n    # Handle T=0 case\n    if T_value < 0.01:\n        T_value = 0.01  # Prevent division by zero\n    \n    beta = 1.0 / T_value\n    \n    # Smart initialization based on temperature\n    config = initialstate(N, dim, model, T_value)\n\n    m_i, e_i, corr_avg, connected_corr = run_simulation(config, beta, eqSteps, mcSteps, N, dim, model, delta, update_type)\n\n \n    filename = os.path.join(output_folder, f\"run-T{T_value:.3f}N{N}D{dim}-{model}-{update_type}.npz\")\n    np.savez(filename,\n             energy=e_i,\n             magnetisation=m_i,\n             correlation=corr_avg,\n             connected_correlation=connected_corr,)\n    \n    return T_value, N, m_i, e_i, corr_avg\n\n\n\n\n# MAIN LOOP\n\n\n\ndef create_data(output_folder, nt, n_list, eqSteps, mcSteps, T_arr, dim, model, delta, update_type):\n    if os.path.exists(output_folder):\n        print(f\"Folder '{output_folder}' already exists.\")\n    else:\n        os.makedirs(output_folder)\n    \n\n    T_arr = np.copy(T_arr)\n    T_arr[T_arr < 0.01] = 0.01\n    \n    params_filepath = os.path.join(output_folder, \"simulation_parameters.npz\")\n    np.savez(params_filepath,\n             nt=nt,\n             n_list=np.array(n_list),\n             eqSteps=eqSteps,\n             mcSteps=mcSteps,\n             T_arr=T_arr,\n             dim=dim,\n             model=model,\n             delta=delta,\n             update_type=update_type)\n    print(f\"Simulation parameters saved to {params_filepath}\")\n    \n    \n    Tc = 2.269 if dim == 2 else 4.51\n    critical_tasks = []\n    normal_tasks = []\n    \n    for N in n_list:\n        for T_val in T_arr:\n            if abs(T_val - Tc) < 0.5:\n                critical_tasks.append((N, T_val, eqSteps, mcSteps))\n            else:\n                normal_tasks.append((N, T_val, eqSteps, mcSteps))\n    \n    all_tasks = critical_tasks + normal_tasks\n    total_tasks = len(all_tasks)\n    completed_tasks = 0\n    \n    # Increase number of processes based on available CPU cores\n    num_processes = mp.cpu_count()\n    print(f\"Using {num_processes} CPU cores for parallel processing\")\n    \n    pool = mp.Pool(processes=8)\n    sim_func = partial(simulate_temp, output_folder=output_folder, dim=dim, model=model, delta=delta, update_type=update_type)\n    \n    for result in pool.imap_unordered(sim_func, all_tasks):\n        completed_tasks += 1\n        print(f\"Progress: {completed_tasks}/{total_tasks} simulations completed.\")\n    \n    pool.close()\n    pool.join()\n\n\n\n# ==========================================================\n# MAIN EXECUTION\n# ==========================================================\nif __name__ == '__main__':\n    output_folder = \"metropolis1\"\n\n    nt          = 1                    # Number of temperature points (reduced for efficiency)\n    n_list      = [32]      # Lattice sizes\n    eqSteps     = 1024 * 100             # Equilibration sweeps (reduced)\n    mcSteps     = 1024 * 100            # Measurement sweeps (reduced)\n    \n    # Focus more points near the critical temperature\n    # T_low = np.linspace(0.5, 1.8, nt//4)\n    # T_crit = np.linspace(1.9, 2.6, nt//2)  # More points near critical point\n    # T_high = np.linspace(2.7, 4.0, nt//4)\n    # T_arr = np.concatenate([T_low, T_crit, T_high])\n    \n    #T_arr = np.linspace(2.1, 2.5, nt)\n    T_arr = [2.275]\n    \n    dim         = 2                       # 2 or 3\n    model       = 'ising'                 # 'ising', 'xy', or 'heisenberg'\n    delta       = 0.3                     # For local moves (not used in cluster)\n    update_type = 'local'               # Choose 'local' or 'cluster'\n    \n    create_data(output_folder, nt, n_list, eqSteps, mcSteps, T_arr, dim, model, delta, update_type)\n\n```\n:::\n\n\n",
    "supporting": [
      "main_code_text_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}