{
  "hash": "869deb5718531c202b36d0373a92d70b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Main Code\"\nformat: html\nexecute:\n  eval: false\n  echo: true  # Ensures code still appears\n  freeze: auto  # Prevents execution unless manually triggered\n\n---\n\n::: {#af434172 .cell execution_count=1}\n``` {.python .cell-code}\n# -*- coding: utf-8 -*-\n\"\"\"\nSpyder Editor\n\nThis is a temporary script file.\n\"\"\"\nfrom __future__ import division\nimport numpy as np\nfrom numpy.random import rand\nimport matplotlib.pyplot as plt\nfrom numba import njit\nimport scipy.stats \nimport tqdm\n\n#----------------------------------------------------------------------\n##  BLOCK OF FUNCTIONS USED IN THE MAIN CODE\n#----------------------------------------------------------------------\n\n\ndef initialstate(N):   \n    ''' generates a random spin configuration for initial condition'''\n    state = 2*np.random.randint(2, size=(N,N))-1\n    return state\n\n@njit\ndef mcmove(config, beta, N):\n    '''Monte Carlo move using Metropolis algorithm '''\n    for i in range(N):\n        for j in range(N):\n                a = np.random.randint(0, N)\n                b = np.random.randint(0, N)\n                s =  config[a, b]\n                nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]\n                cost = 2*s*nb\n                if cost < 0:\n                    s *= -1\n                elif rand() < np.exp(-cost*beta):\n                    s *= -1\n                config[a, b] = s\n    return config\n\n@njit\ndef calcEnergy(config, N):\n    '''Energy of a given configuration'''\n    energy = 0\n    for i in range(len(config)):\n        for j in range(len(config)):\n            S = config[i,j]\n            nb = config[(i+1)%N, j] + config[i,(j+1)%N] + config[(i-1)%N, j] + config[i,(j-1)%N]\n            energy += -nb*S\n    return energy/4.\n\n@njit\ndef calcMag(config):\n    '''Magnetization of a given configuration'''\n    mag = np.sum(config)\n    return mag\n\n\n## change these parameters for a smaller (faster) simulation \nnt      = 10      #  number of temperature points\nn       = [8,16,32]         #  size of the lattice, N x N\neqSteps = 1024       #  number of MC sweeps for equilibration\nmcSteps = 1024*10       #  number of MC sweeps for calculation\n\nT       = np.linspace(1.53, 3.28, nt)  #good spread tro show near temperature 3.28\nE,M,C,X = np.zeros(nt), np.zeros(nt), np.zeros(nt), np.zeros(nt)\n#n1, n2  = 1.0/(mcSteps*n*N), 1.0/(mcSteps*mcSteps*N*N) \n# divide by number of samples, and by system size to get intensive values\n\n\n\n#----------------------------------------------------------------------\n#  MAIN PART OF THE CODE\n#----------------------------------------------------------------------\n\n\n\ndef create_data():\n    M_final = []\n    E_final = []\n    \n    for N in n:\n        M = []\n        E = []\n        \n        for tt in range(nt):\n            print(T[tt],N)\n            E1 = M1 = E2 = M2 = 0\n            m_i = np.zeros(mcSteps)\n            e_i = np.zeros(mcSteps)\n            config = initialstate(N)\n            iT=1.0/T[tt]; iT2=iT*iT;\n            \n            \n            for i in range(eqSteps):         # equilibrate\n                mcmove(config, iT, N)           # Monte Carlo moves\n        \n            # for i in tqdm.tqdm(range(mcSteps)):\n            for i in range(mcSteps):\n                mcmove(config, iT, N)           \n                Ene = calcEnergy(config, N)     # calculate the energy\n                Mag = calcMag(config)        # calculate the magnetisation\n                m_i[i]= Mag\n                e_i[i] = Ene\n                \n                \n            print(T[tt],N,m_i.mean()/N**2)\n            # M.append(m_i)\n            # E.append(e_i)\n            np.savez(f\"data/run-T{T[tt]}N{N}.npz\",energy=e_i,magnetisation=m_i)\n            #E[tt] = n1*E1\n            #M[tt] = n1*M1\n            #C[tt] = (n1*E2 - n2*E1*E1)*iT2\n            #X[tt] = (n1*M2 - n2*M1*M1)*iT\n        # M_final.append(M)\n        # E_final.append(E)      \n    \n    # return M_final, E_final\n\n    \ncreate_data()\n# M_final, E_final = creat_data()\n\n\ndef stat_plot_sizes(stat_func, stat_name=\"Statistic\"):\n    \"\"\"\n    stat_func: a function like kurtosis, np.mean, etc.\n    stat_name: label to show on the y-axis\n    \"\"\"\n    \n    # --- Plot Energy statistic vs Temperature ---\n    \n    plt.figure(figsize=(8, 5))\n    for a in range(3):\n        # Compute the statistic for each temperature\n        stat_values_E = [stat_func(energy_samples) for energy_samples in E_final[a]]\n        \n        # Plot\n        plt.plot(T, stat_values_E, marker='o', label=f'N={n[a]}')\n    \n    plt.xlabel(\"Temperature (T)\", fontsize=14)\n    plt.ylabel(f\"{stat_name} of Energy\", fontsize=14)\n    plt.title(f\"{stat_name} of Energy vs Temperature\", fontsize=16)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n    \n    # --- Plot Magnetization statistic vs Temperature ---\n    plt.figure(figsize=(8, 5))\n    for a in range(3):\n        # Compute the statistic for each temperature\n        stat_values_M = [stat_func(mag_samples) for mag_samples in M_final[a]]\n        \n        # Plot\n        plt.plot(T, stat_values_M, marker='s', label=f'N={n[a]}')\n    \n    plt.xlabel(\"Temperature (T)\", fontsize=14)\n    plt.ylabel(f\"{stat_name} of Magnetization\", fontsize=14)\n    plt.title(f\"{stat_name} of Magnetization vs Temperature\", fontsize=16)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\ndef plot_iterations_for_temperature(Final_list, T, temp_index, size_index, property_name):\n    \"\"\"\n    Plots either Magnetization or Energy vs iteration for all lattice sizes\n    at a chosen temperature index.\n    \n    Parameters:\n    -----------\n    M_final      : list of lists of lists\n                   M_final[i][j] is the magnetization time-series for \n                   lattice size n_list[i] at T[j].\n    E_final      : list of lists of lists\n                   E_final[i][j] is the energy time-series for \n                   lattice size n_list[i] at T[j].\n    n_list       : list of lattice sizes used (e.g. [8, 16, 32])\n    T            : array or list of temperatures\n    temp_index   : int\n                   Index in T for which we want to plot property vs iteration\n    property_name: str, optional\n                   'Magnetization' or 'Energy' (default is 'Magnetization')\n    \"\"\"\n    # Create figure\n    plt.figure(figsize=(8, 5))\n    \n    \n    data = M_final[size_index][temp_index]\n    ylabel = property_name\n\n    # Plot data vs iteration\n    plt.plot(range(len(data)), data, label=f'N = {n[size_index]}')\n    \n    # Labeling\n    plt.xlabel(\"Iteration\", fontsize=12)\n    plt.ylabel(ylabel, fontsize=12)\n    plt.title(f\"{ylabel} vs. Iteration at T = {T[temp_index]:.2f}\", fontsize=14)\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\n\n\n\n\n\n# plot_iterations_for_temperature(M_final, T, 2, 2, \"Magnetisation\")\n#stat_plot_sizes(kurtosis, \"Kurtosis\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# class Ising():\n#     ''' Simulating the Ising model '''    \n#     ## monte carlo moves\n#     def mcmove(self, config, N, beta):\n#         ''' This is to execute the monte carlo moves using \n#         Metropolis algorithm such that detailed\n#         balance condition is satisified'''\n#         for i in range(N):\n#             for j in range(N):            \n#                     a = np.random.randint(0, N)\n#                     b = np.random.randint(0, N)\n#                     s =  config[a, b]\n#                     nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]\n#                     cost = 2*s*nb\n#                     if cost < 0:\t\n#                         s *= -1\n#                     elif rand() < np.exp(-cost*beta):\n#                         s *= -1\n#                     config[a, b] = s\n#         return config\n    \n#     def simulate(self):   \n#         ''' This module simulates the Ising model'''\n#         N, temp     = 64, .4        # Initialse the lattice\n#         config = 2*np.random.randint(2, size=(N,N))-1\n#         f = plt.figure(figsize=(15, 15), dpi=80);    \n#         self.configPlot(f, config, 0, N, 1);\n        \n#         msrmnt = 1001\n#         for i in range(msrmnt):\n#             self.mcmove(config, N, 1.0/temp)\n#             if i == 1:       self.configPlot(f, config, i, N, 2);\n#             if i == 4:       self.configPlot(f, config, i, N, 3);\n#             if i == 32:      self.configPlot(f, config, i, N, 4);\n#             if i == 100:     self.configPlot(f, config, i, N, 5);\n#             if i == 1000:    self.configPlot(f, config, i, N, 6);\n                 \n                    \n#     def configPlot(self, f, config, i, N, n_):\n#         ''' This modules plts the configuration once passed to it along with time etc '''\n#         X, Y = np.meshgrid(range(N), range(N))\n#         sp =  f.add_subplot(3, 3, n_ )  \n#         plt.setp(sp.get_yticklabels(), visible=False)\n#         plt.setp(sp.get_xticklabels(), visible=False)      \n#         plt.pcolormesh(X, Y, config, cmap=plt.cm.RdBu);\n#         plt.title('Time=%d'%i); plt.axis('tight')    \n#     plt.show()\n\n# rm = Ising()\n\n# rm.simulate()\n```\n:::\n\n\n",
    "supporting": [
      "main_code_text_files"
    ],
    "filters": [],
    "includes": {}
  }
}