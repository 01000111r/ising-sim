{
  "hash": "65c6df96996875bd84c3b2110cea388a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Main Code\"\nformat: html\nexecute:\n  eval: false\n  echo: true  # Ensures code still appears\n  freeze: auto  # Prevents execution unless manually triggered\n\n---\n\n::: {#5b6d80c0 .cell execution_count=1}\n``` {.python .cell-code}\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom __future__ import division\nimport numpy as np\nfrom numba import njit\nimport math\nimport os\nimport multiprocessing as mp\nfrom functools import partial\n\n# Initialise state\n\ndef initialstate(N, dim, model):\n    \"\"\"\n    Generates a random spin configuration.\n    \n    For 'ising': spins are ±1.\n    For 'xy'   : spins are angles in [0,2π).\n    For 'heisenberg': spins are 3D unit vectors.\n    \n    For 2D: shape (N,N) or (N,N,3); for 3D: shape (N,N,N) or (N,N,N,3).\n    \"\"\"\n    if model == 'ising':\n        if dim == 2:\n            return 2 * np.random.randint(0, 2, size=(N, N)) - 1\n        elif dim == 3:\n            return 2 * np.random.randint(0, 2, size=(N, N, N)) - 1\n    elif model == 'xy':\n        if dim == 2:\n            return np.random.uniform(0, 2*math.pi, size=(N, N))\n        elif dim == 3:\n            return np.random.uniform(0, 2*math.pi, size=(N, N, N))\n    elif model == 'heisenberg':\n        if dim == 2:\n            config = np.random.normal(size=(N, N, 3))\n            for i in range(N):\n                for j in range(N):\n                    norm = math.sqrt(config[i, j, 0]**2 + config[i, j, 1]**2 + config[i, j, 2]**2)\n                    config[i, j, 0] /= norm\n                    config[i, j, 1] /= norm\n                    config[i, j, 2] /= norm\n            return config\n        elif dim == 3:\n            config = np.random.normal(size=(N, N, N, 3))\n            for i in range(N):\n                for j in range(N):\n                    for k in range(N):\n                        norm = math.sqrt(config[i, j, k, 0]**2 + config[i, j, k, 1]**2 + config[i, j, k, 2]**2)\n                        config[i, j, k, 0] /= norm\n                        config[i, j, k, 1] /= norm\n                        config[i, j, k, 2] /= norm\n            return config\n    else:\n        raise ValueError(\"Model must be 'ising', 'xy', or 'heisenberg'.\")\n\n# Metropolis Algorithms\n\n@njit\ndef mcmove2d(config, beta, N, model, delta):\n    \"\"\"\n    One sweep of local Metropolis moves on a 2D lattice.\n    model: 0=ising, 1=xy, 2=heisenberg.\n    \"\"\"\n    num_moves = N * N\n    for k in range(num_moves):\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        r = np.random.random()\n        if model == 0:\n            s = config[i, j]\n            nb = (config[(i+1)%N, j] + config[(i-1)%N, j] +\n                  config[i, (j+1)%N] + config[i, (j-1)%N])\n            cost = 2 * s * nb\n            if cost < 0 or r < math.exp(-beta * cost):\n                config[i, j] = -s\n        elif model == 1:\n            theta = config[i, j]\n            theta_r = config[(i+1)%N, j]\n            theta_l = config[(i-1)%N, j]\n            theta_u = config[i, (j+1)%N]\n            theta_d = config[i, (j-1)%N]\n            oldE = - (math.cos(theta - theta_r) + math.cos(theta - theta_l) +\n                      math.cos(theta - theta_u) + math.cos(theta - theta_d))\n            new_theta = theta + np.random.uniform(-delta, delta)\n            newE = - (math.cos(new_theta - theta_r) + math.cos(new_theta - theta_l) +\n                      math.cos(new_theta - theta_u) + math.cos(new_theta - theta_d))\n            dE = newE - oldE\n            if dE < 0 or r < math.exp(-beta * dE):\n                config[i, j] = new_theta\n        elif model == 2:\n            s0 = config[i, j, 0]\n            s1 = config[i, j, 1]\n            s2 = config[i, j, 2]\n            nb0 = (config[(i+1)%N, j, 0] + config[(i-1)%N, j, 0] +\n                   config[i, (j+1)%N, 0] + config[i, (j-1)%N, 0])\n            nb1 = (config[(i+1)%N, j, 1] + config[(i-1)%N, j, 1] +\n                   config[i, (j+1)%N, 1] + config[i, (j-1)%N, 1])\n            nb2 = (config[(i+1)%N, j, 2] + config[(i-1)%N, j, 2] +\n                   config[i, (j+1)%N, 2] + config[i, (j-1)%N, 2])\n            oldE = - (s0 * nb0 + s1 * nb1 + s2 * nb2)\n            new0 = s0 + delta * np.random.normal()\n            new1 = s1 + delta * np.random.normal()\n            new2 = s2 + delta * np.random.normal()\n            norm = math.sqrt(new0*new0 + new1*new1 + new2*new2)\n            new0 /= norm; new1 /= norm; new2 /= norm\n            new_nb0 = (config[(i+1)%N, j, 0] + config[(i-1)%N, j, 0] +\n                       config[i, (j+1)%N, 0] + config[i, (j-1)%N, 0])\n            new_nb1 = (config[(i+1)%N, j, 1] + config[(i-1)%N, j, 1] +\n                       config[i, (j+1)%N, 1] + config[i, (j-1)%N, 1])\n            new_nb2 = (config[(i+1)%N, j, 2] + config[(i-1)%N, j, 2] +\n                       config[i, (j+1)%N, 2] + config[i, (j-1)%N, 2])\n            newE = - (new0 * new_nb0 + new1 * new_nb1 + new2 * new_nb2)\n            dE = newE - oldE\n            if dE < 0 or r < math.exp(-beta * dE):\n                config[i, j, 0] = new0\n                config[i, j, 1] = new1\n                config[i, j, 2] = new2\n    return config\n\n@njit\ndef mcmove3d(config, beta, N, model, delta):\n    \"\"\"\n    One sweep of local Metropolis moves on a 3D lattice.\n    \"\"\"\n    num_moves = N * N * N\n    for k in range(num_moves):\n        x = np.random.randint(0, N)\n        y = np.random.randint(0, N)\n        z = np.random.randint(0, N)\n        r = np.random.random()\n        if model == 0:\n            s = config[x, y, z]\n            nb = (config[(x+1)%N, y, z] + config[(x-1)%N, y, z] +\n                  config[x, (y+1)%N, z] + config[x, (y-1)%N, z] +\n                  config[x, y, (z+1)%N] + config[x, y, (z-1)%N])\n            cost = 2 * s * nb\n            if cost < 0 or r < math.exp(-beta * cost):\n                config[x, y, z] = -s\n        elif model == 1:\n            theta = config[x, y, z]\n            t1 = config[(x+1)%N, y, z]\n            t2 = config[(x-1)%N, y, z]\n            t3 = config[x, (y+1)%N, z]\n            t4 = config[x, (y-1)%N, z]\n            t5 = config[x, y, (z+1)%N]\n            t6 = config[x, y, (z-1)%N]\n            oldE = - (math.cos(theta - t1) + math.cos(theta - t2) +\n                      math.cos(theta - t3) + math.cos(theta - t4) +\n                      math.cos(theta - t5) + math.cos(theta - t6))\n            new_theta = theta + np.random.uniform(-delta, delta)\n            newE = - (math.cos(new_theta - t1) + math.cos(new_theta - t2) +\n                      math.cos(new_theta - t3) + math.cos(new_theta - t4) +\n                      math.cos(new_theta - t5) + math.cos(new_theta - t6))\n            dE = newE - oldE\n            if dE < 0 or r < math.exp(-beta * dE):\n                config[x, y, z] = new_theta\n        elif model == 2:\n            s0 = config[x, y, z, 0]\n            s1 = config[x, y, z, 1]\n            s2 = config[x, y, z, 2]\n            nb0 = (config[(x+1)%N, y, z, 0] + config[(x-1)%N, y, z, 0] +\n                   config[x, (y+1)%N, z, 0] + config[x, (y-1)%N, z, 0] +\n                   config[x, y, (z+1)%N, 0] + config[x, y, (z-1)%N, 0])\n            nb1 = (config[(x+1)%N, y, z, 1] + config[(x-1)%N, y, z, 1] +\n                   config[x, (y+1)%N, z, 1] + config[x, (y-1)%N, z, 1] +\n                   config[x, y, (z+1)%N, 1] + config[x, y, (z-1)%N, 1])\n            nb2 = (config[(x+1)%N, y, z, 2] + config[(x-1)%N, y, z, 2] +\n                   config[x, (y+1)%N, z, 2] + config[x, (y-1)%N, z, 2] +\n                   config[x, y, (z+1)%N, 2] + config[x, y, (z-1)%N, 2])\n            oldE = - (s0 * nb0 + s1 * nb1 + s2 * nb2)\n            new0 = s0 + delta * np.random.normal()\n            new1 = s1 + delta * np.random.normal()\n            new2 = s2 + delta * np.random.normal()\n            norm = math.sqrt(new0*new0 + new1*new1 + new2*new2)\n            new0 /= norm; new1 /= norm; new2 /= norm\n            new_nb0 = (config[(x+1)%N, y, z, 0] + config[(x-1)%N, y, z, 0] +\n                       config[x, (y+1)%N, z, 0] + config[x, (y-1)%N, z, 0] +\n                       config[x, y, (z+1)%N, 0] + config[x, y, (z-1)%N, 0])\n            new_nb1 = (config[(x+1)%N, y, z, 1] + config[(x-1)%N, y, z, 1] +\n                       config[x, (y+1)%N, z, 1] + config[x, (y-1)%N, z, 1] +\n                       config[x, y, (z+1)%N, 1] + config[x, y, (z-1)%N, 1])\n            new_nb2 = (config[(x+1)%N, y, z, 2] + config[(x-1)%N, y, z, 2] +\n                       config[x, (y+1)%N, z, 2] + config[x, (y-1)%N, z, 2] +\n                       config[x, y, (z+1)%N, 2] + config[x, y, (z-1)%N, 2])\n            newE = - (new0 * new_nb0 + new1 * new_nb1 + new2 * new_nb2)\n            dE = newE - oldE\n            if dE < 0 or r < math.exp(-beta * dE):\n                config[x, y, z, 0] = new0\n                config[x, y, z, 1] = new1\n                config[x, y, z, 2] = new2\n    return config\n\n# Wolf Cluster Algorithms 2D\n\n@njit\ndef wolff_update_2d_ising(config, beta, N):\n    \n    # create array to store sites to be flipped (cluster membership)\n    cluster = np.zeros((N, N), dtype=np.int8)\n    \n    # create stack to store site coordinates to be searched\n    stack = np.empty((N*N, 2), dtype=np.int64)\n    # pointer for number of sites left to search\n    stack_ptr = 0\n    \n    # pick a random site \n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    s0 = config[i, j]\n    \n\n    cluster[i, j] = 1\n    stack[0, 0] = i; stack[0, 1] = j\n    stack_ptr = 1\n    \n    p_add = 1.0 - math.exp(-2.0 * beta)\n\n    while stack_ptr > 0:\n        stack_ptr -= 1\n        # retrieve next site coordinates\n        i = stack[stack_ptr, 0]\n        j = stack[stack_ptr, 1]\n        # For each neighbor:\n        for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):\n            ni = (i + di) % N\n            nj = (j + dj) % N\n            # if neighbor is not yet in the cluster and has the same spin as the seed:\n            if cluster[ni, nj] == 0 and config[ni, nj] == s0:\n                # add neighbor with probability p_add\n                if np.random.random() < p_add:\n                    config[ni, nj] = -config[ni, nj]\n                \n                    cluster[ni, nj] = 1\n                    stack[stack_ptr, 0] = ni\n                    stack[stack_ptr, 1] = nj\n                    stack_ptr += 1\n                    \n                        \n    return config\n\n\n@njit\ndef wolff_update_2d_xy(config, beta, N):\n    \n    # Choose a random reflection direction (unit vector in 2D)\n    phi_ref = np.random.uniform(0, 2*math.pi)\n    \n    # store components\n    r0 = math.cos(phi_ref)\n    r1 = math.sin(phi_ref)\n    \n    # create array to store what needs to be reflected\n    cluster = np.zeros((N, N), dtype=np.int8)\n    \n    # create stack to store what site coordinates needs to be searches\n    stack = np.empty((N*N, 2), dtype=np.int64)\n    # create pointer for number of sites left to search\n    stack_ptr = 0\n    \n    # pick random site\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    \n    # flip seed\n    theta = config[i, j]\n    config[i, j] = (2*phi_ref - theta) % (2*math.pi)\n    \n    cluster[i, j] = 1\n    stack[0, 0] = i; stack[0, 1] = j\n    stack_ptr = 1\n    \n    while stack_ptr > 0:\n        stack_ptr -= 1\n        # retrieve next site coords\n        i = stack[stack_ptr, 0]\n        j = stack[stack_ptr, 1]\n        # For each neighbor:\n        for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):\n            ni = (i+di) % N\n            nj = (j+dj) % N\n            if cluster[ni, nj] == 0:\n                theta_i = config[i, j]\n                theta_n = config[ni, nj]\n                a_i = (math.cos(theta_i)*r0 + math.sin(theta_i)*r1)\n                a_n = (math.cos(theta_n)*r0 + math.sin(theta_n)*r1)\n                \n                p_add = 1.0 - math.exp(min(0,2.0 * beta * a_i * a_n))\n                \n                if np.random.random() < p_add:\n                    config[ni, nj] = (2*phi_ref - theta_n) % (2*math.pi)\n                    cluster[ni, nj] = 1\n                    stack[stack_ptr, 0] = ni\n                    stack[stack_ptr, 1] = nj\n                    stack_ptr += 1\n                    \n    return config\n\n    \n@njit\ndef wolff_update_2d_heisenberg(config, beta, N):\n    \n    # Choose a random reflection vector in R3 using spherical coords\n    theta_r = np.random.uniform(0, 2*math.pi)  \n    phi_r = np.random.uniform(0, math.pi)        \n    \n    # store components\n    r0 = math.sin(phi_r) * math.cos(theta_r)\n    r1 = math.sin(phi_r) * math.sin(theta_r)\n    r2 = math.cos(phi_r)\n    \n    # create array to store sites \n    cluster = np.zeros((N, N), dtype=np.int8)\n    \n    # create stack to store site coordinates to be searched\n    stack = np.empty((N*N, 2), dtype=np.int64)\n    # pointer for number of sites left to search\n    stack_ptr = 0\n    \n    # pick a random site as the seed\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    \n    # compute projection a = S · r for the seed spin\n    a = config[i, j, 0]*r0 + config[i, j, 1]*r1 + config[i, j, 2]*r2\n    \n    #flip seed\n    s0 = config[i, j, 0]\n    s1 = config[i, j, 1]\n    s2 = config[i, j, 2]\n    config[i, j, 0] = s0 - 2 * a * r0\n    config[i, j, 1] = s1 - 2 * a * r1\n    config[i, j, 2] = s2 - 2 * a * r2\n        \n    # mark the seed as in the cluster and add it to the stack\n    cluster[i, j] = 1\n    stack[0, 0] = i; stack[0, 1] = j\n    stack_ptr = 1\n    \n    \n    while stack_ptr > 0:\n        stack_ptr -= 1\n        # retrieve next site coordinates\n        i = stack[stack_ptr, 0]\n        j = stack[stack_ptr, 1]\n        # For each neighbor:\n        for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):\n            ni = (i + di) % N\n            nj = (j + dj) % N\n            if cluster[ni, nj] == 0:\n\n                a_i = config[i, j, 0]*r0 + config[i, j, 1]*r1 + config[i, j, 2]*r2\n                a_n = config[ni, nj, 0]*r0 + config[ni, nj, 1]*r1 + config[ni, nj, 2]*r2\n                \n                p_add = 1.0 - math.exp(2.0 * beta * min(0,a_i * a_n))\n\n                if np.random.random() < p_add:\n                    \n                    s0_i = config[ni, nj, 0]\n                    s1_i = config[ni, nj, 1]\n                    s2_i = config[ni, nj, 2]\n                    a_val = s0*r0 + s1*r1 + s2*r2\n                    config[ni, nj, 0] = s0_i - 2 * a_val * r0\n                    config[ni, nj, 1] = s1_i - 2 * a_val * r1\n                    config[ni, nj, 2] = s2_i - 2 * a_val * r2\n                    \n                    cluster[ni, nj] = 1\n                    stack[stack_ptr, 0] = ni\n                    stack[stack_ptr, 1] = nj\n                    stack_ptr += 1\n                        \n    return config\n\n#Wrapper for cluster update\n@njit\ndef wolff_update_2d(config, beta, N, model):\n    if model == 0:\n        return wolff_update_2d_ising(config, beta, N)\n    elif model == 1:\n        return wolff_update_2d_xy(config, beta, N)\n    elif model == 2:\n        return wolff_update_2d_heisenberg(config, beta, N)\n    \n\n# 3D Cluster Updates\n@njit\ndef wolff_update_3d_ising(config, beta, N):\n    # create array to store sites to be flipped (cluster membership)\n    cluster = np.zeros((N, N, N), dtype=np.int8)\n    \n    # create stack to store site coordinates to be searched\n    stack = np.empty((N*N*N, 3), dtype=np.int64)\n    stack_ptr = 0\n    \n    # pick a random site\n    x = np.random.randint(0, N)\n    y = np.random.randint(0, N)\n    z = np.random.randint(0, N)\n    s0 = config[x, y, z]\n    \n    # mark seed as in the cluster and add to stack\n    cluster[x, y, z] = 1\n    stack[0, 0] = x; stack[0, 1] = y; stack[0, 2] = z\n    stack_ptr = 1\n    \n    p_add = 1.0 - math.exp(-2.0 * beta)\n    \n    # Grow the cluster\n    while stack_ptr > 0:\n        stack_ptr -= 1\n        x = stack[stack_ptr, 0]\n        y = stack[stack_ptr, 1]\n        z = stack[stack_ptr, 2]\n        # iterate over the six nearest neighbors in 3D\n        for dx, dy, dz in ((1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)):\n            nx = (x + dx) % N\n            ny = (y + dy) % N\n            nz = (z + dz) % N\n            if cluster[nx, ny, nz] == 0 and config[nx, ny, nz] == s0:\n                if np.random.random() < p_add:\n                    # flip neighbor spin on the fly\n                    config[nx, ny, nz] = -config[nx, ny, nz]\n                    cluster[nx, ny, nz] = 1\n                    stack[stack_ptr, 0] = nx\n                    stack[stack_ptr, 1] = ny\n                    stack[stack_ptr, 2] = nz\n                    stack_ptr += 1\n                    \n    return config\n\n@njit\ndef wolff_update_3d_xy(config, beta, N):\n    # Choose a random reflection direction (unit vector in 2D, same for each site)\n    phi_ref = np.random.uniform(0, 2*math.pi)\n    r0 = math.cos(phi_ref)\n    r1 = math.sin(phi_ref)\n    \n    # create array to store what needs to be reflected (cluster membership)\n    cluster = np.zeros((N, N, N), dtype=np.int8)\n    \n    # create stack to store site coordinates to be searched\n    stack = np.empty((N*N*N, 3), dtype=np.int64)\n    stack_ptr = 0\n    \n    # pick a random site (seed)\n    x = np.random.randint(0, N)\n    y = np.random.randint(0, N)\n    z = np.random.randint(0, N)\n    theta = config[x, y, z]\n    \n    # flip seed unconditionally\n    config[x, y, z] = (2*phi_ref - theta) % (2*math.pi)\n    cluster[x, y, z] = 1\n    stack[0, 0] = x; stack[0, 1] = y; stack[0, 2] = z\n    stack_ptr = 1\n    \n    # Grow the cluster\n    while stack_ptr > 0:\n        stack_ptr -= 1\n        x = stack[stack_ptr, 0]\n        y = stack[stack_ptr, 1]\n        z = stack[stack_ptr, 2]\n        # iterate over the six nearest neighbors in 3D\n        for dx, dy, dz in ((1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)):\n            nx = (x + dx) % N\n            ny = (y + dy) % N\n            nz = (z + dz) % N\n            \n            if cluster[nx, ny, nz] == 0:\n                theta_i = config[x, y, z]\n                theta_n = config[nx, ny, nz]\n                a_i = (math.cos(theta_i)*r0 + math.sin(theta_i)*r1)\n                a_n = (math.cos(theta_n)*r0 + math.sin(theta_n)*r1)\n                \n                p_add = 1.0 - math.exp(min(0,2.0 * beta * a_i * a_n))\n                \n                if np.random.random() < p_add:\n                    config[nx, ny, nz] = (2*phi_ref - theta_n) % (2*math.pi)\n                    cluster[nx, ny, nz] = 1\n                    stack[stack_ptr, 0] = nx\n                    stack[stack_ptr, 1] = ny\n                    stack[stack_ptr, 2] = nz\n                    stack_ptr += 1    \n                \n                        \n    return config\n\n\n@njit\ndef wolff_update_3d_heisenberg(config, beta, N):\n    # Choose a random reflection vector in R^3 using spherical coordinates\n    theta_r = np.random.uniform(0, 2*math.pi)\n    phi_r = np.random.uniform(0, math.pi)\n    r0 = math.sin(phi_r)*math.cos(theta_r)\n    r1 = math.sin(phi_r)*math.sin(theta_r)\n    r2 = math.cos(phi_r)\n    \n    # create array to store sites (cluster membership)\n    cluster = np.zeros((N, N, N), dtype=np.int8)\n    \n    # create stack to store site coordinates to be searched\n    stack = np.empty((N*N*N, 3), dtype=np.int64)\n    stack_ptr = 0\n    \n    # pick a random site as the seed\n    x = np.random.randint(0, N)\n    y = np.random.randint(0, N)\n    z = np.random.randint(0, N)\n    \n    # compute projection a = S · r for the seed spin\n    a = config[x, y, z, 0]*r0 + config[x, y, z, 1]*r1 + config[x, y, z, 2]*r2\n    # flip seed unconditionally using the reflection operation\n    s0 = config[x, y, z, 0]\n    s1 = config[x, y, z, 1]\n    s2 = config[x, y, z, 2]\n    config[x, y, z, 0] = s0 - 2 * a * r0\n    config[x, y, z, 1] = s1 - 2 * a * r1\n    config[x, y, z, 2] = s2 - 2 * a * r2\n    \n    cluster[x, y, z] = 1\n    stack[0, 0] = x; stack[0, 1] = y; stack[0, 2] = z\n    stack_ptr = 1\n    \n    # Grow the cluster\n    while stack_ptr > 0:\n        stack_ptr -= 1\n        x = stack[stack_ptr, 0]\n        y = stack[stack_ptr, 1]\n        z = stack[stack_ptr, 2]\n        # iterate over the six nearest neighbors in 3D\n        for dx, dy, dz in ((1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)):\n            nx = (x + dx) % N\n            ny = (y + dy) % N\n            nz = (z + dz) % N\n            if cluster[nx, ny, nz] == 0:\n\n                a_i = config[x, y, z, 0]*r0 + config[x, y, z, 1]*r1 + config[x, y, z, 2]*r2\n                a_n = config[nx, ny, nz, 0]*r0 + config[nx, ny, nz, 0]*r1 + config[nx, ny, nz, 0]*r2\n                \n                p_add = 1.0 - math.exp(2.0 * beta * min(0,a_i * a_n))\n\n                if np.random.random() < p_add:\n                    \n                    s0_i = config[nx, ny, nz, 0]\n                    s1_i = config[nx, ny, nz, 1]\n                    s2_i = config[nx, ny, nz, 2]\n                    a_val = s0*r0 + s1*r1 + s2*r2\n                    config[nx, ny, nz, 0] = s0_i - 2 * a_val * r0\n                    config[nx, ny, nz, 1] = s1_i - 2 * a_val * r1\n                    config[nx, ny, nz, 2] = s2_i - 2 * a_val * r2\n                    \n                    cluster[nx, ny, nz, 0] = 1\n                    stack[stack_ptr, 0] = nx\n                    stack[stack_ptr, 1] = ny\n                    stack[stack_ptr, 2] = nz\n                    stack_ptr += 1\n                \n    return config\n\n\n@njit\ndef wolff_update_3d(config, beta, N, model):\n    if model == 0:\n        return wolff_update_3d_ising(config, beta, N)\n    elif model == 1:\n        return wolff_update_3d_xy(config, beta, N)\n    elif model == 2:\n        return wolff_update_3d_heisenberg(config, beta, N)\n\n# ==========================================================\n# COMBINED MEASUREMENTS (energy, magnetisation, correlation)\n# ==========================================================\n@njit\ndef measure2d_all(config, N, model):\n    R = N // 2\n    energy = 0.0\n    if model == 0:\n        mag = 0.0\n        for i in range(N):\n            for j in range(N):\n                S = config[i, j]\n                energy += -S * (config[i, (j+1)%N] + config[(i+1)%N, j])\n                mag += S\n        corr = np.zeros(R+1, dtype=np.float64)\n        count = np.zeros(R+1, dtype=np.int64)\n        for i in range(N):\n            for j in range(N):\n                for r in range(R+1):\n                    corr[r] += config[i, j] * config[(i+r)%N, j]\n                    count[r] += 1\n        for r in range(R+1):\n            if count[r] > 0:\n                corr[r] /= count[r]\n        return energy, mag, corr\n    elif model == 1:\n        sum_cos = 0.0\n        sum_sin = 0.0\n        for i in range(N):\n            for j in range(N):\n                theta = config[i, j]\n                energy += - (math.cos(theta - config[i, (j+1)%N]) +\n                            math.cos(theta - config[(i+1)%N, j]))\n                sum_cos += math.cos(theta)\n                sum_sin += math.sin(theta)\n        mag = math.sqrt(sum_cos*sum_cos + sum_sin*sum_sin)\n        corr = np.zeros(R+1, dtype=np.float64)\n        count = np.zeros(R+1, dtype=np.int64)\n        for i in range(N):\n            for j in range(N):\n                for r in range(R+1):\n                    corr[r] += math.cos(config[i, j] - config[(i+r)%N, j])\n                    count[r] += 1\n        for r in range(R+1):\n            if count[r] > 0:\n                corr[r] /= count[r]\n        return energy, mag, corr\n    elif model == 2:\n        sum0 = 0.0; sum1 = 0.0; sum2 = 0.0\n        for i in range(N):\n            for j in range(N):\n                s0 = config[i, j, 0]\n                s1 = config[i, j, 1]\n                s2 = config[i, j, 2]\n                energy += - ((s0 * config[i, (j+1)%N, 0] + s1 * config[i, (j+1)%N, 1] + s2 * config[i, (j+1)%N, 2]) +\n                           (s0 * config[(i+1)%N, j, 0] + s1 * config[(i+1)%N, j, 1] + s2 * config[(i+1)%N, j, 2]))\n                sum0 += s0; sum1 += s1; sum2 += s2\n        mag = math.sqrt(sum0*sum0 + sum1*sum1 + sum2*sum2)\n        corr = np.zeros(R+1, dtype=np.float64)\n        count = np.zeros(R+1, dtype=np.int64)\n        for i in range(N):\n            for j in range(N):\n                for r in range(R+1):\n                    s0 = config[i, j, 0]\n                    s1 = config[i, j, 1]\n                    s2 = config[i, j, 2]\n                    t0 = config[(i+r)%N, j, 0]\n                    t1 = config[(i+r)%N, j, 1]\n                    t2 = config[(i+r)%N, j, 2]\n                    corr[r] += s0*t0 + s1*t1 + s2*t2\n                    count[r] += 1\n        for r in range(R+1):\n            if count[r] > 0:\n                corr[r] /= count[r]\n        return energy, mag, corr\n\n@njit\ndef measure3d_all(config, N, model):\n    R = N // 2\n    energy = 0.0\n    if model == 0:\n        mag = 0.0\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    S = config[x, y, z]\n                    energy += -S * (config[(x+1)%N, y, z] + config[x, (y+1)%N, z] + config[x, y, (z+1)%N])\n                    mag += S\n        corr = np.zeros(R+1, dtype=np.float64)\n        count = np.zeros(R+1, dtype=np.int64)\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    for r in range(R+1):\n                        corr[r] += config[x, y, z] * config[(x+r)%N, y, z]\n                        count[r] += 1\n        for r in range(R+1):\n            if count[r] > 0:\n                corr[r] /= count[r]\n        return energy, mag, corr\n    elif model == 1:\n        sum_cos = 0.0; sum_sin = 0.0\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    theta = config[x, y, z]\n                    energy += - (math.cos(theta - config[(x+1)%N, y, z]) +\n                                math.cos(theta - config[x, (y+1)%N, z]) +\n                                math.cos(theta - config[x, y, (z+1)%N]))\n                    sum_cos += math.cos(theta)\n                    sum_sin += math.sin(theta)\n        mag = math.sqrt(sum_cos*sum_cos + sum_sin*sum_sin)\n        corr = np.zeros(R+1, dtype=np.float64)\n        count = np.zeros(R+1, dtype=np.int64)\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    for r in range(R+1):\n                        corr[r] += math.cos(config[x, y, z] - config[(x+r)%N, y, z])\n                        count[r] += 1\n        for r in range(R+1):\n            if count[r] > 0:\n                corr[r] /= count[r]\n        return energy, mag, corr\n    elif model == 2:\n        sum0 = 0.0; sum1 = 0.0; sum2 = 0.0\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    s0 = config[x, y, z, 0]\n                    s1 = config[x, y, z, 1]\n                    s2 = config[x, y, z, 2]\n                    energy += - ((s0 * config[(x+1)%N, y, z, 0] + s1 * config[(x+1)%N, y, z, 1] + s2 * config[(x+1)%N, y, z, 2]) +\n                                (s0 * config[x, (y+1)%N, z, 0] + s1 * config[x, (y+1)%N, z, 1] + s2 * config[x, (y+1)%N, z, 2]) +\n                                (s0 * config[x, y, (z+1)%N, 0] + s1 * config[x, y, (z+1)%N, 1] + s2 * config[x, y, (z+1)%N, 2]))\n                    sum0 += s0; sum1 += s1; sum2 += s2\n        mag = math.sqrt(sum0*sum0 + sum1*sum1 + sum2*sum2)\n        corr = np.zeros(R+1, dtype=np.float64)\n        count = np.zeros(R+1, dtype=np.int64)\n        for x in range(N):\n            for y in range(N):\n                for z in range(N):\n                    for r in range(R+1):\n                        s0 = config[x, y, z, 0]\n                        s1 = config[x, y, z, 1]\n                        s2 = config[x, y, z, 2]\n                        t0 = config[(x+r)%N, y, z, 0]\n                        t1 = config[(x+r)%N, y, z, 1]\n                        t2 = config[(x+r)%N, y, z, 2]\n                        corr[r] += s0*t0 + s1*t1 + s2*t2\n                        count[r] += 1\n        for r in range(R+1):\n            if count[r] > 0:\n                corr[r] /= count[r]\n        return energy, mag, corr\n\n# ==========================================================\n# SIMULATION ROUTINE\n# ==========================================================\ndef run_simulation(config, beta, eqSteps, mcSteps, N, dim, model, delta, update_type):\n    \"\"\"\n    Runs equilibration then measurement sweeps.\n    If update_type == 'local', local Metropolis moves are used.\n    If update_type == 'cluster', Wolff cluster updates are used.\n    Measurements (energy, magnetisation, correlation) are computed in one pass.\n    \"\"\"\n    # Convert model to numeric code: 0=ising, 1=xy, 2=heisenberg.\n    if model == 'ising':\n        mcode = 0\n    elif model == 'xy':\n        mcode = 1\n    elif model == 'heisenberg':\n        mcode = 2\n    else:\n        raise ValueError(\"Unknown model\")\n    \n    # Equilibration:\n    for _ in range(eqSteps):\n        if update_type == 'local':\n            if dim == 2:\n                mcmove2d(config, beta, N, mcode, delta)\n            else:\n                mcmove3d(config, beta, N, mcode, delta)\n        elif update_type == 'cluster':\n            if dim == 2:\n                wolff_update_2d(config, beta, N, mcode)\n            else:\n                wolff_update_3d(config, beta, N, mcode)\n    # Measurement:\n    m_i = np.empty(mcSteps, dtype=np.float64)\n    e_i = np.empty(mcSteps, dtype=np.float64)\n    R = N // 2\n    corr_sum = np.zeros(R+1, dtype=np.float64)\n    for i in range(mcSteps):\n        if update_type == 'local':\n            if dim == 2:\n                mcmove2d(config, beta, N, mcode, delta)\n            else:\n                mcmove3d(config, beta, N, mcode, delta)\n        elif update_type == 'cluster':\n            if dim == 2:\n                wolff_update_2d(config, beta, N, mcode)\n            else:\n                wolff_update_3d(config, beta, N, mcode)\n        if dim == 2:\n            e, m, corr = measure2d_all(config, N, mcode)\n        else:\n            e, m, corr = measure3d_all(config, N, mcode)\n        e_i[i] = e\n        m_i[i] = m\n        corr_sum += corr\n    corr_avg = corr_sum / mcSteps\n    return m_i, e_i, corr_avg\n\n# ==========================================================\n# SIMULATION WRAPPER (for multiprocessing)\n# ==========================================================\ndef simulate_temp(args, output_folder, dim, model, delta, update_type):\n    \"\"\"\n    Runs simulation for given N and T_value and saves data.\n    \"\"\"\n    N, T_value, eqSteps, mcSteps = args\n    beta = 1.0 / T_value\n    config = initialstate(N, dim, model)\n    m_i, e_i, corr_avg = run_simulation(config, beta, eqSteps, mcSteps, N, dim, model, delta, update_type)\n    filename = os.path.join(output_folder, f\"run-T{T_value:.3f}N{N}D{dim}-{model}-{update_type}.npz\")\n    np.savez(filename,\n             energy=e_i,\n             magnetisation=m_i,\n             correlation=corr_avg)\n    print(f\"Finished: T={T_value:.3f}, N={N}, dim={dim}, model={model}, update={update_type}, avg m/site={m_i.mean()/(N**dim):.3f}\")\n    return T_value, N, m_i, e_i, corr_avg\n\n# ==========================================================\n# DATA CREATION LOOP\n# ==========================================================\ndef create_data(output_folder, nt, n_list, eqSteps, mcSteps, T_arr, dim, model, delta, update_type):\n    if os.path.exists(output_folder):\n        print(f\"Folder '{output_folder}' already exists.\")\n    else:\n        os.makedirs(output_folder)\n    params_filepath = os.path.join(output_folder, \"simulation_parameters.npz\")\n    np.savez(params_filepath,\n             nt=nt,\n             n_list=np.array(n_list),\n             eqSteps=eqSteps,\n             mcSteps=mcSteps,\n             T_arr=T_arr,\n             dim=dim,\n             model=model,\n             delta=delta,\n             update_type=update_type)\n    print(f\"Simulation parameters saved to {params_filepath}\")\n    tasks = []\n    for N in n_list:\n        for T_val in T_arr:\n            tasks.append((N, T_val, eqSteps, mcSteps))\n    total_tasks = len(tasks)\n    completed_tasks = 0\n    pool = mp.Pool(processes=5)\n    sim_func = partial(simulate_temp, output_folder=output_folder, dim=dim, model=model, delta=delta, update_type=update_type)\n    for result in pool.imap_unordered(sim_func, tasks):\n        completed_tasks += 1\n        print(f\"Progress: {completed_tasks}/{total_tasks} simulations completed.\")\n    pool.close()\n    pool.join()\n\n# ==========================================================\n# MAIN EXECUTION\n# ==========================================================\nif __name__ == '__main__':\n    output_folder = \"data10\"\n    nt          = 50                      # Number of temperature points\n    n_list      = [16, 32, 64]            # Lattice sizes\n    eqSteps     = 1024 * 10               # Equilibration sweeps\n    mcSteps     = 1024 * 10               # Measurement sweeps\n    T_arr       = np.linspace(3.5, 5.5, nt) # Temperature array\n    dim         = 3                       # 2 or 3\n    model       = 'xy'                    # 'ising', 'xy', or 'heisenberg'\n    delta       = 0.3                     # For local moves (not used in cluster)\n    update_type = 'cluster'               # Choose 'local' or 'cluster'\n    \n    create_data(output_folder, nt, n_list, eqSteps, mcSteps, T_arr, dim, model, delta, update_type)\n```\n:::\n\n\n",
    "supporting": [
      "main_code_text_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}